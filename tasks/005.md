### **Задача 5: Загрузка страницы альбома с выбором быстрых рекомендаций и общим таймаутом (а-ля Яндекс.Музыка)**

Контекст:

Представь, что ты работаешь над музыкальным сервисом вроде Яндекс.Музыки или Spotify. Твоя задача — реализовать загрузку данных для страницы музыкального альбома. Когда пользователь открывает страницу альбома, нужно показать:

1. Информацию об альбоме (название, исполнитель, обложка).
2. Список треков этого альбома.
3. Список похожих альбомов (рекомендации).

Загрузка этих данных занимает время. Особенно рекомендации — у сервиса может быть несколько разных систем (или "движков") для подбора рекомендаций, и они могут работать с разной скоростью в зависимости от нагрузки или сложности алгоритма. Нам хочется получить рекомендации от той системы, которая ответит *быстрее всего*.

Кроме того, вся страница альбома (информация + треки + самые быстрые рекомендации) должна загрузиться достаточно быстро, скажем, не дольше 2.5 секунд. Если за это время данные не пришли, лучше показать пользователю сообщение об ошибке, чем заставлять его ждать бесконечно.

**Что нужно сделать:**

1. **Имитация загрузки деталей альбома:** Создай асинхронную функцию `fetchAlbumDetails(albumId)`.
    - Возвращает `Promise`.
    - Через 0.8 секунды разрешается (resolve) объектом `{ id: albumId, title: 'Синтаксический Сахар', artist: 'Нейросеть Нейронович', tracks: ['Асинхронная Баллада', 'Цикл Бесконечности', 'Баг в Матрице'] }`.
2. **Имитация запроса рекомендаций:** Создай асинхронную функцию `fetchRecommendations(engineId, albumId)`.
    - `engineId` - это условное название системы рекомендаций (например, 'engine-A', 'engine-B').
    - Возвращает `Promise`.
    - Промис разрешается (resolve) через *случайное* время (от 0.5 до 2 секунд) массивом строк (названия похожих альбомов), например `[\`Похожий альбом от ${engineId} 1`, `Похожий альбом от ${engineId} 2`]`. Укажи в результате, какой движок дал ответ.
3. **Имитация таймаута:** Создай функцию `timeoutPromise(delay, message)`.
    - Возвращает `Promise`, который через `delay` миллисекунд отклоняется (rejects) с ошибкой `new Error(message)`.
4. **Основная логика загрузки страницы:** Напиши `async function loadAlbumPage(albumId, recommendationEngines, totalTimeout)`.
    - `albumId` - ID альбома (просто строка).
    - `recommendationEngines` - массив строк с ID движков рекомендаций (например, `['engine-A', 'engine-B', 'engine-C']`).
    - `totalTimeout` - общее время ожидания в мс (например, `2500`).
5. **`Внутри loadAlbumPage:`**
    - **Шаг А: Получение самых быстрых рекомендаций:**
        - Используй `Promise.race()` и метод `map` для массива `recommendationEngines`, чтобы одновременно запустить `fetchRecommendations` для *всех* движков.
        - Сохрани промис, возвращаемый `Promise.race`, в переменную (например, `fastestRecommendationsPromise`). Этот промис разрешится результатом от самого быстрого движка.
    - **Шаг Б: Параллельная загрузка основных данных:**
        - Используй `Promise.all()` для одновременного запуска:
            - Загрузки деталей альбома (`fetchAlbumDetails(albumId)`).
            - Ожидания самых быстрых рекомендаций (`fastestRecommendationsPromise` из шага А).
        - Сохрани промис, возвращаемый `Promise.all`, в переменную (например, `dataFetchPromise`). Он разрешится, когда и детали, и самые быстрые рекомендации будут получены.
    - **Шаг В: Реализация общего таймаута:**
        - Создай промис таймаута с помощью `timeoutPromise(totalTimeout, '...')`.
        - Используй `Promise.race()` для "соревнования" между промисом загрузки данных (`dataFetchPromise` из шага Б) и промисом таймаута.
        - Дождись результата этого финального `Promise.race` с помощью `await`.
6. **Обработка ошибок:** Оберни логику шага В (финальный `await Promise.race(...)`) в блок `try...catch`.
7. **Вывод результата:**
    - Если `dataFetchPromise` успел завершиться до таймаута, выведи в консоль детали альбома, треклист и рекомендации (указав, от какого движка они пришли).
    - Если сработал таймаут (или произошла другая ошибка), выведи сообщение об ошибке из блока `catch`.

Почему задача полезна?

Эта задача на реальном примере музыкального сервиса показывает, как комбинировать разные инструменты асинхронности для сложных сценариев:

- `Promise.race` используется для выбора самого быстрого из нескольких альтернативных источников данных (системы рекомендаций).
- `Promise.all` используется для параллельной загрузки разных, но обязательных частей контента (детали альбома и *какие-нибудь* рекомендации).
- Еще один Promise.race используется для установки общего ограничения по времени на всю операцию.
    
    Ты учишься строить гибкие и отказоустойчивые системы, которые не только быстро загружают данные из разных мест, но и гарантируют приемлемое время отклика для пользователя.
    

**Подсказки:**

1. Вспомни, что `Promise.race(promises)` разрешается или отклоняется так же, как и *первый* из промисов в массиве `promises`, который завершится. Как это использовать для выбора самого быстрого движка рекомендаций? Как это использовать для реализации таймаута?
2. Структура `loadAlbumPage` будет примерно такой:
    
    ```
    async function loadAlbumPage(albumId, recommendationEngines, totalTimeout) {
      try {
        // Промис для самых быстрых рекомендаций
        const fastestRecommendationsPromise = Promise.race(
          recommendationEngines.map(engineId => fetchRecommendations(engineId, albumId))
        );
    
        // Промис для загрузки деталей И самых быстрых рекомендаций
        const dataFetchPromise = Promise.all([
          fetchAlbumDetails(albumId),
          fastestRecommendationsPromise // Передаем промис!
        ]);
    
        // Промис для таймаута
        const overallTimeoutPromise = timeoutPromise(totalTimeout, `Страница альбома ${albumId} не загрузилась за ${totalTimeout} мс`);
    
        // Финальное соревнование: данные ИЛИ таймаут
        const result = await Promise.race([
          dataFetchPromise,
          overallTimeoutPromise
        ]);
    
        // Если мы здесь, dataFetchPromise успел
        const [albumDetails, recommendations] = result; // Результат Promise.all
        console.log('--- Страница альбома загружена ---');
        console.log('Альбом:', albumDetails.title, 'Исполнитель:', albumDetails.artist);
        console.log('Треки:', albumDetails.tracks);
        console.log(`Рекомендации (от ${recommendations.engine}):`, recommendations.similarAlbums);
    
      } catch (error) {
        console.error('--- Ошибка загрузки страницы альбома ---');
        console.error('Причина:', error.message);
      }
    }
    
    ```
    
3. Реализуй `fetchAlbumDetails` с фиксированной задержкой. Реализуй `fetchRecommendations` со случайной задержкой (`Math.random() * 1500 + 500`) и возвратом объекта, включающего `engineId` и массив рекомендаций. Реализуй `timeoutPromise`. Поэкспериментируй с разными значениями `totalTimeout` и количеством/скоростью движков рекомендаций.
