### **Задача 3: Загрузка страницы видео (YouTube) с обработкой частичных ошибок**

Контекст:

Ты продолжаешь работать над YouTube. Теперь твоя задача — загрузить данные для страницы просмотра видео. На этой странице нужно показать само видео (условно, его название и описание), комментарии к нему и список рекомендованных видео. Все эти данные нужно запросить с сервера одновременно, чтобы ускорить загрузку. Однако, иногда какой-то из запросов может не сработать (например, комментарии временно недоступны, или произошла случайная сетевая ошибка). В идеале, нужно показать пользователю ту часть страницы, которая загрузилась успешно, а для проблемной части вывести сообщение об ошибке.

**Что нужно сделать:**

1. Создай три асинхронные функции, имитирующие запросы. **Каждая из них должна иметь некоторую вероятность сбоя.** Для имитации случайного сбоя используй `Math.random()` внутри `setTimeout`. Если сгенерированное случайное число меньше заданной вероятности успеха (например, 0.9 для 90% успеха), вызывай `resolve` с данными. В противном случае — вызывай `reject` с объектом ошибки `new Error('Сообщение об ошибке')`.
    - `fetchVideoDetails(videoId)`: Возвращает `Promise`. С вероятностью 90% через 1 секунду разрешается (resolve) объектом `{ title: 'Глубокое погружение в асинхронный JavaScript', description: 'Разбираем event loop, промисы и async/await на пальцах.' }`. С вероятностью 10% отклоняется (rejects) с ошибкой `new Error('Не удалось загрузить детали видео')`.
    - `fetchComments(videoId)`: Возвращает `Promise`. С вероятностью 70% он через 1.5 секунды разрешается (resolve) массивом комментариев `['Отличное объяснение! Наконец-то понял event loop.', 'А как насчет Web Workers?', 'Лайк за async/await!']`. С вероятностью 30% он отклоняется (rejects) с ошибкой `new Error('Не удалось загрузить комментарии')` через то же время.
    - `fetchRelatedVideos(videoId)`: Возвращает `Promise`. С вероятностью 95% через 0.8 секунды разрешается (resolve) массивом названий видео `['Что такое замыкания в JS?', 'Паттерны проектирования для начинающих']`. С вероятностью 5% отклоняется (rejects) с ошибкой `new Error('Не удалось загрузить похожие видео')`.
2. Напиши `async function loadVideoPage(videoId)`.
3. Внутри `loadVideoPage` используй `Promise.all()` для *одновременного* запуска всех трех функций `fetch*`.
4. Используй `try...catch` для обработки *общей* ошибки, если `Promise.all` будет отклонен (из-за сбоя в *любой* из функций `fetch*`).
5. В блоке `try` после `await Promise.all()` выведи все успешно загруженные данные (название, описание, комментарии, похожие видео).
6. В блоке `catch` выведи сообщение о том, что *часть данных* загрузить не удалось, и укажи причину (`error.message`).
7. **Важно:** Подумай, как `Promise.all` ведет себя при ошибке одного из промисов. Что произойдет с результатами остальных? Как можно было бы улучшить обработку, чтобы всегда получать результаты успешно выполненных запросов (подсказка: `Promise.allSettled`, но его реализовывать не нужно, достаточно упомянуть в размышлениях или посмотреть в подсказках).

Почему задача полезна?

Эта задача учит работать с ситуациями, когда не все идет по плану при параллельной загрузке. Promise.all отлично подходит для ускорения, но он "падает" целиком при первой же ошибке. В реальных интерфейсах часто лучше показать пользователю хоть что-то, чем вообще ничего. Понимание ограничений Promise.all и знание о существовании альтернатив вроде Promise.allSettled (который ждет выполнения всех промисов, независимо от их исхода) позволяет создавать более надежные и отказоустойчивые приложения. Ты учишься не просто запускать задачи параллельно, но и грамотно обрабатывать частичные сбои, что важно для сложных интерфейсов.

**Подсказки:**

1. Вспомни, что `Promise.all` ждет выполнения всех промисов, но отклоняется (rejects), как только отклоняется *хотя бы один* из них. Как использовать `try...catch` с `await Promise.all()`?
2. Оберни `await Promise.all([...])` в блок `try`. В блоке `catch` ты получишь ошибку от первого отклоненного промиса. Выведи `error.message`. В блоке `try` после `await` ты сможешь получить доступ к результатам, *только если все промисы успешно разрешились*.
    
    ```
    async function loadVideoPage(videoId) {
      console.log(`Загрузка страницы для видео ${videoId}...`);
      try {
        const [details, comments, related] = await Promise.all([
          fetchVideoDetails(videoId), // Может упасть
          fetchComments(videoId), // Может упасть
          fetchRelatedVideos(videoId) // Может упасть
        ]);
        // Этот код выполнится только если ВСЕ успешно
        console.log('--- Страница загружена полностью ---');
        console.log('Детали:', details);
        console.log('Комментарии:', comments);
        console.log('Похожие видео:', related);
      } catch (error) {
        // Сюда попадем, если хотя бы один промис отклонен
        console.error('--- Ошибка загрузки части страницы ---');
        console.error('Причина:', error.message);
        // Мы не имеем доступа к результатам успешных промисов здесь
        // с использованием Promise.all
      }
    }
    
    ```
    
3. Чтобы получить результаты даже при частичных сбоях, в реальном коде часто используют `Promise.allSettled([...])`. Он возвращает массив объектов, описывающих результат *каждого* промиса (`{status: 'fulfilled', value: ...}` или `{status: 'rejected', reason: ...}`). Тебе не нужно его реализовывать, но полезно знать. Для текущей задачи достаточно использовать `Promise.all` и обработать общую ошибку в `catch`. Убедись, что твои функции `fetch*` действительно иногда отклоняют промисы с помощью `Math.random()` и `reject(new Error(...))`. Вызови `loadVideoPage` несколько раз, чтобы увидеть разные исходы.
